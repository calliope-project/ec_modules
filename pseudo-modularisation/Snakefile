configfile: "config.yaml"
configfile: "modules/light/config.yaml"
configfile: "modules/dark/config.yaml"
configfile: "modules/grey/config.yaml"

DATAPATH = config["setup"]["datapath"]
OUTPATH = config["setup"]["outpath"]

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# This section uses snakemake's "module" functionality.
# Advantages:
# - Guaranteed avoidance of rule name conflicts.
# - Modules only see their own configuration, nothing else.
# - --delete-all-output can find and eliminate outputs from all modules.
# Disadvantages:
# - the DAG still shows all processes, so there is no abstraction of complexity.
# - submodule is not "isolated": paths must refer to base folder
# - submodule cannot define its configuration from within (triggers errors)
module module_dark:
    snakefile: "modules/dark/Snakefile"
    config: config["dark"]
use rule * from module_dark as module_dark_*

module module_light:
    snakefile: "modules/light/Snakefile"
    config: config["light"]
use rule * from module_light as module_light_*

module module_grey:
    snakefile: "modules/grey/Snakefile"
    config: config["grey"]
use rule * from module_grey as module_grey_*
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

rule global_task:
    message: "Emulate global configuration files."
    output:
        f"{DATAPATH}/global.txt"
    shell:
        "touch {output}"

rule global_subtask:
    message: "This function necessitates another input, and creates another output."
    input:
        rules.global_task.output
    output:
        f"{DATAPATH}/subprocess_global.txt"
    shell:
        "touch {output}"

rule global_module_hook:
    message: "This guy is meant to ensure module output is produced."
    default_target: True
    input:
        rules.module_dark_output.output,
        rules.module_light_output.output,
        rules.module_grey_output.output,
        rules.global_subtask.output,
    output:
        f"{OUTPATH}/final.txt"
    shell:
        "touch {output}"

